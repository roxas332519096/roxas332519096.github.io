<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>面试题 | RoxasDengBlog</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script></head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">RoxasDengBlog</a></h1></div><p class="m-desc">心之所向，无惧无悔,<br>愿求仁得仁，复无怨怼！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">面试题</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2019/07/28/面试题/">2019-07-28</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/面试题/">面试题</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ol>
<li><p>html语义化</p>
</li>
<li><p>meta viewport<br> github head</p>
<pre><code class="bash"> &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1&quot;&gt;
</code></pre>
</li>
<li><p>用过什么html5标签</p>
<p> header footer main article<br> canvas video audio<br> 搜索mdn</p>
</li>
<li><p>H5是什么?<br> 移动端页面</p>
<pre><code class="bash"> 1. 页面素材预加载,createJS的preloadJS
 2. 音乐加载播放技术,createJS的soundJS或H5的audio
 3. 可滑动页面,swiper.js
 4. 可涂抹擦除,canvas叠层
 5. 动态文字和图片,css3动画与js动画
 6. 填报报名 html表单
 7. 支持分享自定义的文案和图片 微信jssdk

 炫酷效果:egret/cocos2d/
</code></pre>
</li>
</ol>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ol>
<li><p>盒模型<br>content-box 内容区宽度<br>border-box content+padding+border</p>
</li>
<li><p>实现垂直居中</p>
<ol>
<li><p>table自带功能</p>
<pre><code class="bash">&lt;table&gt;
 &lt;tr&gt;
     &lt;td&gt;内容&lt;/td&gt;
 &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>2 100%高度的after before 加上inline block</p>
<p>2.1 方案一</p>
<pre><code class="bash">&lt;div class=&quot;parent&quot;&gt;
 &lt;span class=&quot;before&quot;&gt;&lt;/span&gt;
 &lt;div class=&quot;child&quot;&gt;内容&lt;/div&gt;
 &lt;span class=&quot;after&quot;&gt;&lt;/span&gt;
&lt;/div&gt;

&lt;style&gt;
 .parent{
     text-align:center;//水平居中
     padding:10px 0;//让父元素有高度,但不必要
 }
 .child{
         display: inline-block;
         vertical-align: middle;
     }
 .before,.after{
         display: inline-block;
         hegiht:100%;
         vertical-align: middle;
     }
&lt;/style&gt;
</code></pre>
<p>2.2 方案一优化版</p>
<pre><code class="bash">&lt;div class=&quot;parent&quot;&gt;
 &lt;div class=&quot;child&quot;&gt;内容&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
 .parent{
     text-align:center;//水平居中
     padding:10px 0;//让父元素有高度,但不必要
 }
 .child{
         display: inline-block;
         vertical-align: middle;
     }
 parent::before,parent::after{
         cotent:&#39;&#39;;
         display: inline-block;
         hegiht:100%;
         vertical-align: middle;
     }
&lt;/style&gt;
</code></pre>
<p>3 postion+负margin子元素宽高的一半</p>
<pre><code class="bash">&lt;div class=&quot;parent&quot;&gt;
 &lt;div class=&quot;child&gt;内容&lt;/div&gt;
&lt;/div&gt;
&lt;style&gt;
 .parent {
     position: relative;
 }

 .child {
     position: absolute;
     width: 300px;
     height: 100px;
     top: 50%;
     left: 50%;
     margin-top: -150px;
     margin-left: -50px;
 }
&lt;/style&gt;
</code></pre>
</li>
<li><p>transform: translate(-50%,-50%)</p>
</li>
<li><p>flex</p>
</li>
<li><p>absolute top/bottom/left/right:0;margin:auto</p>
</li>
</ol>
</li>
<li><p>flex属性</p>
</li>
<li><p>BFC是什么<br> 块级格式化上下文，常见的例子有：</p>
<ol>
<li>overflow:hidden</li>
<li>浮动元素</li>
<li>绝对定位元素</li>
<li>inline-block</li>
<li><p>flex或者inline-flex</p>
<p>解决了什么问题：</p>
</li>
<li>清除浮动</li>
<li>防止margin合并</li>
</ol>
</li>
<li><p>CSS选择器优先级</p>
<ol>
<li>越具体优先级越高</li>
<li>写在后面的,覆盖写在前面的</li>
<li>importan!最高 少用</li>
</ol>
</li>
<li><p>清除浮动<br> .clearfix{</p>
<pre><code> content:&#39;&#39;;
 display:block;
 clear:both;
</code></pre><p> }<br> 加到容器上,里面子元素浮动被清除.</p>
</li>
<li><p>重绘重排</p>
<ol>
<li>重绘：元素外观发生改变，如元素填充颜色</li>
<li>重排：布局发生改变，需要重新生成布局，重新排列元素<br> 减少重排 <pre><code> i. 脱离文档流
 ii. 避免频繁操作样式
 iii. 减少重排范围，尽量将样式加载具体元素上，而不是它的父级 
</code></pre><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3></li>
</ol>
</li>
<li><p>ES6属性</p>
</li>
<li><p>Promise.all Promise.race</p>
<pre><code class="bash"> //Promise

 function xxx(){
     return new Promise(function(resolve,reject){
         setTimeout(()=&gt;{
             if(xxx){
                 resolve(&#39;data&#39;)
             }else{
                 reject(new Error(&#39;error&#39;))
             }
         })
     }
 }

 //Promise.all([fn,fn2,fn3]).then(res1,res2,res3) 
 //Promise.race([fn,fn2,fn3]).then(res)
</code></pre>
</li>
<li><p>函数防抖,函数节流<br> 防抖:事件触发,假如事件在一定时间内不再触发,则调用函数</p>
<pre><code class="bash"> function 防抖(fn,time){
     let timer = null;
     return ()=&gt;{
         if(timer){
             clearTimeout()
         }
         timer = setTimeout(()=&gt;{
             fn()
             timer = null
         },time)
     }
 }
</code></pre>
<p> 节流:一段时间内只能调用一次函数</p>
<pre><code class="bash"> function 节流(fn, time) {
     let doing = false;
     return () =&gt; {
         if (doing === false) {
             doing = true;
             fn()
             setTimeout(() =&gt; {
                 doing = false;
             }, time)
         }
     }
 }
</code></pre>
</li>
<li><p>手写ajax</p>
<pre><code class="bash"> var request = new XMLHttpRequest();
 request.open(&#39;GET&#39;,&#39;url&#39;)
 request.onreadystatechange = function(){
     if(request.readyState === 4){
         if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300 || request.status === 304){
             console.log(request.responseText)
         }else{
             console.log(&#39;error&#39;)
         }
     }
 }
 request.send()
</code></pre>
<p> 用promise写ajax</p>
<pre><code class="bash"> function ajax(method,data,url){
     return new Promise(function(resolve,reject){
         let request = new XMLHttpRequest()
         request.open(method,url)
         request.onreadystatechange = function(){
             if(request.readyState === 4){
                 if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300 || request.status === 304){
                     resolve(request.responseText)
                 }else{
                     reject(&#39;error&#39;)
                 }
             }
         }
         request.send(data)
     })
 }
</code></pre>
</li>
<li><p>this</p>
<pre><code class="bash"> 1. fn()

     this =&gt; window
 2. obj.fn()
     this =&gt; obj
 3. fn.call(x)
 4. fn.apply(x)
 5. fn.apply(x)
     this =&gt; x
 6. new Fn()
     this =&gt; 新的对象

 7. fn = ()=&gt;{}
     this =&gt; 外面的this

</code></pre>
</li>
<li><p>闭包/立即执行函数</p>
<p> 声名一个匿名函数，然后立即执行它。在Es6之前，只能通过它来[创建局部作用域]。<br> 闭包：</p>
<pre><code class="bash"> const add2 = function(){
     var count
     return function add(){
         count +1 = 1 //访问了外部变量的函数
     }
 }()
</code></pre>
<p> 闭包优点： </p>
<ol>
<li>避免污染全局环境。</li>
<li>提供对局部变量的间接访问。</li>
<li>维持变量，使其不被垃圾回收。</li>
</ol>
</li>
<li><p>jsonp/cors/跨域</p>
<p> jsonp,动态创建script标签,src指向请求地址,把callback函数名当做参数传给服务器,服务器把数据包装在callback内,传回来,然后script执行callback.</p>
<p> cors:跨域资源共享</p>
<ol>
<li>对于简单请求，乙站点在响应头添加Access-Control-Allow-Origin:http：//甲站点</li>
<li>对于复杂请求，如POST，乙站点需要：<ol>
<li>响应OPTIONS请求，响应中添加如下的响应头<pre><code class="bash">Access-Control-Allow-Origin:http：//甲站点
Access-Control-Allow-Mthods:POST,GET,OPTIONS
Access-Control-Allow-Headers:Contet-type
</code></pre>
</li>
<li>响应POST请求，在响应中添加Access-Control-Allow-Origin头</li>
</ol>
</li>
<li>如果需要附带Cookie，JS中需要在AJAX里设置xhr.withCredentials = true</li>
</ol>
</li>
</ol>
<ol start="8">
<li><p>async await 捕获异常</p>
<pre><code class="bash"> async function fn(){
     try{
         let a = await Promise.reject(&#39;error&#39;)
     }catch(error){
         console.log(error)
     }
 }
</code></pre>
</li>
<li><p>深拷贝</p>
<ol>
<li>递归</li>
<li>判断类型</li>
<li>检测循环引用(环)</li>
<li><p>不可能拷贝 <strong>proto</strong></p>
<pre><code class="bash">const cache = new Map()//缓存已拷贝部分
function clone(object){
 if(cache.get(object)){//假如已缓存，直接返回
     return cache.get(object)
 }
 let result
 if(! (object instanceof Object) ){//基础类型直接返回
     return object
 }else if(object instanceof Array){
     result = []
 }else if(object instanceof Function){
    result = function(){return object.apply(this,arguments)}
 }else if(object instanceof Date){
     result = new Date(object-0)
 }
 else if(object instanceof RegExp){
     result = new RegExp(a)
 }else{
     result = {}
 }
 cache.set(object,result)//插入缓存
 for(let key in object){
     if(object.hasOwnProperty(key)){//非继承属性
         result[key] = clone(object[key])
     }
 }
 return result
}
</code></pre>
</li>
</ol>
</li>
<li><p>正则实现trim</p>
<pre><code class="bash">function trim(string){
    return string.replace(/^\s+|\s+$/g,&#39;&#39;)
}
</code></pre>
</li>
<li><p>继承</p>
<p>es5</p>
<pre><code class="bash">function Animal(name){
    this.name = name
}

Animal.prototype.move = function(){
    console.log(&#39;move&#39;)
}

function Dog(){
    Animal.apply(this,arguments)
    this.foot = 4
}

let f = function(){}
f.prototype = Animal.prototype;
Dog.prototype = new f()

Dog.prototype.constructor = Dog

Dog.prototype.say = function(){
    console.log(&#39;汪汪汪&#39;)
}

let a = new Dog(&#39;aaa&#39;) //{name:&#39;aaa&#39;,foot:4}
a.name
a.move()
a.foot
a.say()
</code></pre>
<p>es6</p>
<pre><code class="bash">class Animal{
    constructor(name){
        this.name = name
    }
    move(){
        console.log(&#39;move&#39;)
    }
}

class Dog extends Animal {
    constructor(name){
        super(name)
        this.foot = 4
    }
    say(){
        console.log(&#39;汪汪汪&#39;)
    }
}
</code></pre>
<p>JS的new做了什么</p>
<ol>
<li>创建临时对象/新对象</li>
<li>绑定原型</li>
<li>指定this = 临时对象</li>
<li>执行构造函数</li>
<li>返回临时对象</li>
</ol>
</li>
<li><p>去重</p>
<ol>
<li><p>hash（计数排序的思路）</p>
<pre><code class="bash"> var uniq = function(a){
     var map = {}
     for(let i =0;i&lt;a.length;i++){
         let number = a[i]
         if(number === undefined){continue}
         if(number in map){//已重复
             continue
         }
         map[number] = true //map里第一次出现
     }
     const result = []
     for(let key in map){
         result.push(key)
     }
     return result
 }
</code></pre>
<p> 缺点：数字只能是字符串，同时有数字跟字符串无法分出（’1’,1）</p>
</li>
<li><p>set</p>
<pre><code class="bash"> Array.form(new Set(a))
</code></pre>
</li>
<li>Weekmap<pre><code class="bash"> var uniq = function(a){
     var map = new Map()
     for(let i =0;i&lt;a.length;i++){
         let number = a[i]
         if(number === undefined){continue}
         if(map.has(number)){//已重复
             continue
         }
       map.set(number,true) //map里第一次出现
     }
    return [...map.keys()]
 }
</code></pre>
 缺点：兼容性差了一些</li>
</ol>
</li>
<li><p>手写Promise</p>
<pre><code class="bash">class Promises2 {
    #status = &#39;pending&#39;
    constructor(fn) {
        this.q = []//创建一个队列
        const resolve = (data) =&gt; {
            this.#status = &#39;fulfilled&#39;
            const f1f2 = this.q.shift()//出列，返回第一个
            const x = f1f2[0].call(undefined, data)
            if (x instanceof Promise2) {
                x.then(data =&gt; {
                    resolve(data)
                }, (reason) =&gt; {
                    reject(reason)
                })
            } else {
                resolve(x)
            }
        };
        const reject = (reason) =&gt; {
            this.#status = &#39;rejected&#39;
            const f1f2 = this.q.shift()
            const x = f1f2[1].call(undefined, data)
            if (x instanceof Promise2) {
                x.then(data =&gt; {
                    resolve(data)
                }, (reason) =&gt; {
                    reject(reason)
                })
            } else {
                resolve(x)
            }
        }
        fn.call(undefined, resolve, reject)
    }
    then(f1, f2) {
        this.q.push([f1, f2])//入列
    }
}
</code></pre>
</li>
<li><p>手写Promise.all</p>
<ol>
<li>知道Promise上写而不是在原型上写</li>
<li>知道all的参数（Promise数组）和返回值（新Promise对象）</li>
<li>知道用数组来记录结果</li>
<li>知道只要一个reject就整体reject</li>
</ol>
<pre><code class="bash">Promise.myAll = function (list) {
    const results = []
    let count = 0
    return new Promise((resolve,reject) =&gt; {
        list.map((promise,index) =&gt; {
            promise.then((r) =&gt; {
                results[index] = r
                count += 1
                if (count === list.length) {
                    resolve(results)
                }
            },
                (reason) =&gt; {
                    reject(reason)
                }
            )
        })
    })
}
</code></pre>
</li>
<li><p>JS垃圾回收机制</p>
<ol>
<li>什么是垃圾<ol>
<li>没有引用的就是垃圾</li>
<li>如果是对象互相引用，形成环也是垃圾</li>
</ol>
</li>
<li>如何捡垃圾<br> 遍历和计数，如有引用则进行标记，最后把没有标记的删除</li>
<li>前端又有其特殊性（JS进程和DOM进程）</li>
</ol>
</li>
</ol>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><ol>
<li><p>事件委托<br>好处：</p>
<ol>
<li>节省监听器</li>
<li>动态监听<br>坏处：</li>
<li><p>调试比较复杂，不容易发现监听者。</p>
<pre><code class="bash">ul.addEventListener(&#39;click&#39;, function(e){
 if(e.target.tagName.toLowerCase() === &#39;li&#39;){
     fn() // 执行某个函数
 }
})
</code></pre>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li>mouse事件写一个可拖动的div<ol>
<li>记录鼠标按下的坐标</li>
<li>记录当前拖动坐标</li>
<li>移动距离=拖动坐标-拖动坐标</li>
<li>元素的style.left/top+移动距离<pre><code class="bash">  var position = null
  var drag = false
  xxx.addEventListener(&#39;mousedown&#39;,function(e){
          drag = true;
          position = [e.clientX,e.clientY]
  })
  document.addEventListener(&#39;mousemove&#39;,function(e){
      if(!drag) return //没有移动就别拖
          let X = e.clientX
          let Y = e.clientY
          let left = parseInt(xxx.style.left || 0 )
          let top = parseInt(xxx.style.top || 0 )
          moveX = X - position[0]
          moveY = Y - position[1]
          xxx.style.left = left + moveX + &#39;px&#39;
          xxx.style.top = top + moveY + &#39;px&#39;
          position = [X,Y]
  })
  document.addEventListener(&#39;mouseup&#39;,function(e){
      drag = false
  })
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ol>
<li><p>HTTP状态码</p>
<p> HTTP status cat</p>
</li>
<li><p>HTTP缓存有哪几种<br> http1.1：</p>
<p> Cache-control（强缓存）: max-age 多少秒内过期 是相对时间 无请求 在本地<br> Etag（协商缓存）:MD5 在服务器 有请求 304<br> http1.0：服务器最后修改时间，只能存到秒 有请求 304<br> Expire（强缓存）:日期 什么时候过期 Bug:本地时间用户可以调 无请求 在本地<br> Last-Modified（协商缓存）：</p>
</li>
<li><p>GET 和 POST</p>
<p> 错:(背)</p>
<ol>
<li>POST安全 GET不安全</li>
<li>GET URL有长度限制 POST没有</li>
<li>GET 参数放在URL POST 放在消息体</li>
<li>GET  只需要一个报文 POST 需要两个以上</li>
<li>GET 幂等(不改变数据) POST 不幂等(改变数据库)</li>
<li>GET结果会被缓存，POST结果不会被缓存<br>对: 只语义上的区别 get 获取数据 post 提交数据</li>
</ol>
</li>
<li><p>Cookie Session Localstrage Sessionstrage 区别</p>
<ol>
<li>Cookie与Localstrage，cookie会被发送到服务器，4k，Localstrage不带请求，在本地，5M</li>
<li>Localstrage与Sessionstrage，前者不会过期，后者会话结束后过期</li>
<li>Cookie与Session，cookie存在浏览器，Session存在服务器，Session基于Cooike实现，具体做法就是把SessionId存在Cookie里</li>
</ol>
</li>
<li><p>HTTP2 HTTP1区别</p>
<ol>
<li>HTTP/2使用了二进制传输，而且将head和body分成帧来传输；HTTP/1.1是字符串传输。</li>
<li>HTTP/2使用多路复用，HTTP/1.1不支持。多路复用简单来说就是一个TCP连接从单车道（不是单行道）变成了几百个双向通行的车道。</li>
<li>HTTP/2可以压缩header，但是HTTP/1.1不行。</li>
<li>HTTP/2支持服务器推送，但是HTTP/1.1不行。</li>
</ol>
</li>
<li><p>HTTP和HTTPS区别</p>
<ol>
<li>HTTP是明文传输的，不安全；HTTPS是加密传输的，非常安全。</li>
<li>HTTP使用80端口，HTTPS使用443端口。</li>
<li>HTTP较快，HTTPS较慢。</li>
<li>HTPS的证书一般需要购买，HTTP不需要证书。</li>
</ol>
</li>
<li><p>TCP三次握手和四次挥手<br>建立TCP连接时sever和client会经历三次握手</p>
<ol>
<li>浏览器向服务器发送TCP数据,SYN(X)//请求数据</li>
<li>服务器向浏览器发送TCP数据,ACK(X+1),SYN(y)//表示同意</li>
<li>浏览器向服务器发送TCP数据,ACK(y)//表示同意</li>
</ol>
<p>关闭TCP连接时sever和client会经历四次挥手</p>
<ol start="4">
<li>浏览器向服务器发送TCP数据,FIN(X)//表示已完成</li>
<li>服务器向浏览器发送TCP数据,ACK(X+1)/表示同意</li>
<li>服务器向浏览器发送TCP数据,FIN(y)/表示已完成</li>
<li><p>浏览器向服务器发送TCP数据,ACK(y)//表示同意</p>
<p>为什么2，3步骤不合并？因为2，3中间服务器很可能还有数据要发送，不能提前发送FIN</p>
</li>
</ol>
</li>
</ol>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ol>
<li><p>watch computed 区别</p>
<p> watch是属性监听无缓存<br> computed是计算属性,有缓存</p>
</li>
<li><p>生命周期</p>
<p> created:初始化<br> mouted:数据请求<br> updated:更新时做<br> destory:销毁时</p>
</li>
<li><p>组件通信</p>
<ol>
<li>父子 props $emit(‘事件’,data) $on(‘事件’,function(){})</li>
<li>eventBus eventBus = new Vue();eventBus.$emit() eventBus.$on</li>
<li>Vuex</li>
</ol>
</li>
<li><p>Vuex</p>
<p> 状态管理工具</p>
<p> state<br> getter<br> mutatiion<br> action</p>
<p> …map</p>
</li>
<li><p>vue2如何实现双向绑定的？</p>
<ol>
<li>v-model是v-bind：value和v-on:input的语法糖<br> a: v-bind:value实现了data=&gt;ui的单向绑定<br> b： v-on:input实现了ui=&gt;data的单向绑定</li>
<li>如何实现<br> a： Object.defineProperty 给data创建getter/setter，用于监听data的改变，data一变就会安排改变ui<br> b：后者通过template compiler给DOM添加事件监听，DOM input的值改变了就会去修改data</li>
</ol>
</li>
<li><p>vue.set</p>
<p> vm.$set(‘目标对象’,key,value)</p>
</li>
<li><p>vue-router</p>
</li>
</ol>
<p>vue的官方管理器</p>
<p>重定向<br>histroy模式<br>懒加载 improt(‘./文件路径’)</p>
<ol start="8">
<li>路由守卫</li>
</ol>
<pre><code class="bash">router.beforeEach((to, from, next) =&gt; {
  // ...
})

next() //去to
next(false) //去from
next(&#39;/login&#39;) //去login 

组件内
 beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },

全局
router.beforeResolve
</code></pre>
<ol start="9">
<li><p>拦截</p>
</li>
<li><p>混用<br><code>`</code>bash<br>//登录成功后将token存到seesionStorage</p>
</li>
</ol>
<p>seesionstorage.setItem(‘token’,data.token)</p>
<p>//路由守卫<br>router.beforeEach((to,from,next)=&gt;{<br>    if(to.patch === ‘/login’) return next()<br>    if(!sessionStorage.getItem(‘token’)) return next(‘/login’)<br>    next()<br>})</p>
<p>//请求拦截<br>axios.interceptors.request.use(function(config){<br>    config.headers.Authorization = seesionStorage.getItem(‘token’)<br>    return config<br>})</p>
<p>//响应拦截<br>axios.interceptors.response.ues(function(response){<br>    if(response.data.meta.status === 401){<br>        location.href = ‘#/login’<br>    }else{<br>        return response<br>    }<br>})</p>
<pre><code>
### vue3
1. vue3为什么使用proxy？
 1. 弥补Object.defineProperty的两个不足
    a：动态创建的data属性需要Vue.set来赋值，vue3用了proxy就不需要了。
    b：基于性能考虑，vue2篡改数组的7个API（push等），vue3用了proxy就不需要了。
 2. defineProperty需要提前递归遍历data做到响应式，而proxy可以在真正用到深层数据的时候再做响应式（惰性）

2. vue3为什么使用composition API？
   1. composition api比mixins、高阶组件、extends、Renderless Components等更好，原因有三：
    a:模板中的数据来源不清晰。
    b：命名空间冲突。
    c：性能

    2. 更适合TypeScript

3. vue3对比vue2做了哪些改动？
   1. createApp()代替了new Vue()
   2. v-model代替了以前的v-model和sync
   3. 根元素可以不止一个元素了
   4. 新增teleport传送门
   5. destory被改名为unmounted了
   6. ref属性支持函数了

### Webpack

1. 用过什么loader plugin
    1. loader 转换器
        1. babel-loader 把 JS/TS 变成 JS
        2. ts-loader 把 TS 变成 JS，并提示类型错误
        3. markdown-loader 把 markdown 变成 html
        4. html-loader 把 html 变成 JS 字符串
        5. sass-loader 把 SASS/SCSS 变成 CSS
        6. css-loader 把 CSS 变成 JS 字符串
        7. style-loader 把 JS 字符串变成 style 标签
        8. postcss-loader 把 CSS 变成更优化的 CSS
        9. vue-loader 把单文件组件（SFC）变成 JS 模块
        10. thread-loader 用于多进程打包

    2. plugin 扩展器
         1. html-webpack-plugin 用于创建 HTML 页面并自动引入 JS 和 CSS
         2. clean-webpack-plugin 用于清理之前打包的残余文件
         3. mini-css-extract-plugin 用于将 JS 中的 CSS 抽离成单独的 CSS 文件
         4. SplitChunksPlugin 用于代码分包（Code Split）
         5. DllPlugin + DllReferencePlugin 用于避免大依赖被频繁重新打包，大幅降低打
         包时间
         6. eslint-webpack-plugin 用于检查代码中的错误
         7. DefinePlugin 用于在 webpack config 里添加全局变量
         8. copy-webpack-plugin 用于拷贝静态文件到 dist

    二者的区别
    3. loader 是文件加载器（这句废话很重要）
        功能：能够对文件进行编译、优化、混淆（压缩）等，比如 babel-loader /
    4. plugin 是 webpack 插件（这句废话也很重要）
        功能：能实现更多功能，比如定义全局变量、Code Split、加速编译等
        运行时机：在整个打包过程（以及前后）都能运行

2. webpack 如何解决开发时的跨域问题？
    在开发时，我们的页面在 localhost:8080 ，JS 直接访问后端接口（如
    https://xiedaimala.com 或 http://localhost:3000 ）会报跨域错误。
    为了解决这个问题，可以在 webpack.config.js 中添加如下配置：
    ```bash
    module.exports = {
    //...
    devServer: {
        proxy: {
        &#39;/api&#39;: {
                target: &#39;http://xiedaimala.com&#39;,
                changeOrigin: true,
                },
            },
        },
    };
</code></pre><pre><code>此时，在 JS 中请求 /api/users 就会自动被代理到
http://xiedaimala.com/api/users 。
如果希望请求中的 Origin 从 8080 修改为 xiedaimala.com，可以添加 changeOrigin:
true 。
如果要访问的是 HTTPS API，那么就需要配置 HTTPS 证书，否则会报错。
不过，如果在 target 下面添加 secure: false ，就可以不配置证书且忽略 HTTPS 报
错。
总之，记住常用选项就行了。
</code></pre><ol start="3">
<li><p>如何实现 tree-shaking？<br>是什么<br> tree-shaking 就是让没有用到的 JS 代码不打包，以减小包的体积。<br> 怎么做<br> 背下文档说的这几点：</p>
<ol>
<li>怎么删<br>   a. 使用 ES Modules 语法（即 ES6 的 import 和 export 关键字）<br>   b. CommonJS 语法无法 tree-shaking（即 require 和 exports 语法）<br>   c. 引入的时候只引用需要的模块<pre><code>   i. 要写 import {cloneDeep} from &#39;lodash-es&#39; 因为方便 tree-shaking
   ii. 不要写 import _ from &#39;lodash&#39; 因为会导致无法 tree-shaking 无用模块
</code></pre></li>
<li>怎么不删：在 package.json 中配置 sideEffects，防止某些文件被删掉<br>   a. 比如我 import 了 x.js，而 x.js 只是添加了 window.x 属性，那么 x.js 就要放到<br>   sideEffects 里<br>   b. 比如所有被 import 的 CSS 都要放在 sideEffects 里</li>
<li>怎么开启：在 webpack config 中将 mode 设置为 production（开发环境没必要tree-shaking）<br>   a. mode: production 给 webpack 加了非常多优化</li>
</ol>
</li>
<li><p>如何提高 webpack 构建速度？</p>
<ol>
<li>使用 DllPlugin 将不常变化的代码提前打包，并复用，如 vue、react</li>
<li>使用 thread-loader 或 HappyPack（过时）进行多线程打包</li>
<li>处于开发环境时，在 webpack config 中将 cache 设为 true，也可用 cacheloader（过时）</li>
<li>处于生产环境时，关闭不必要的环节，比如可以关闭 source map</li>
<li>网传的 HardSourceWebpackPlugin 已经一年多没更新了，谨慎使用</li>
</ol>
</li>
<li><p>webpack 与 vite 的区别是什么？</p>
<ol>
<li>开发环境区别<br>a. vite 自己实现 server，不对代码打包，充分利用浏览器对 <script type="module"> 的支持<br>  i. 假设 main.js 引入了 vue<br>  ii. 该 server 会把 import { createApp } from ‘vue’ 改为 import {<br>  createApp } from “/node_modules/.vite/vue.js” 这样浏览器就知道去哪<br>  里找 vue.js 了<br>b. webpack-dev-server 常使用 babel-loader 基于内存打包，比 vite 慢很多很多很多<br>  i. 该 server 会把 vue.js 的代码（递归地）打包进 main.js</li>
<li>生产环境区别<br>a. vite 使用 rollup + esbuild 来打包 JS 代码<br>b. webpack 使用 babel 来打包 JS 代码，比 esbuild 慢很多很多很多<pre><code>  i. webpack 能使用 esbuild 吗？可以，你要自己配置（很麻烦）。
</code></pre></li>
<li>文件处理时机<br>a. vite 只会在你请求某个文件的时候处理该文件<br>b. webpack 会提前打包好 main.js，等你请求的时候直接输出打包好的 JS 给你<br>目前已知 vite 的缺点有：</li>
<li>热更新常常失败，原因不清楚</li>
<li>有些功能 rollup 不支持，需要自己写 rollup 插件</li>
<li>不支持非现代浏览器</li>
</ol>
</li>
</ol>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><pre><code>XSS-Cross-Site Scripting（跨站脚本攻击）
    i. 反射型XSS 
        防御：对url的查询参数进行转义后再输出到页面。  
        ```bash
        app.get(&#39;/welcome&#39;, function(req, res) {
            //对查询参数进行编码，避免反射型 XSS攻击
            res.send(`${encodeURIComponent(req.query.type)}`); 
        });
        ```
    ii. DOM型XSS
        防御： 对html进行转义
        ```bash
        function encodeHtml(str) {
            return str.replace(/&quot;/g, &#39;&amp;quot;&#39;)
                    .replace(/&#39;/g, &#39;&amp;apos;&#39;)
                    .replace(/&lt;/g, &#39;&amp;lt;&#39;)
                    .replace(/&gt;/g, &#39;&amp;gt;&#39;);
        }
        ```

CSRF-Cross-site request forgery（跨站请求伪造）
    防御：
        i. Token验证
        ii.  Cookie添加SameSite属性，在跨站请求时不会被发送

区别一：

CSRF：需要用户先登录网站A，获取 cookie。

XSS：不需要登录。

区别二：（原理的区别）

CSRF：是利用网站A本身的漏洞，去请求网站A的api。

XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。
</code></pre><h3 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h3><pre><code class="bash">var a = {name:&#39;a&#39;}
a.x = a = {}
a.x ? //undefined

解:
1.确定a是什么
2执行从右往左


var a = {name:&#39;a&#39;} //指向内存124
a.x = a = {}

先确定a.x的a是124
a = {} //将a指向126空对象,所以新的变量a是空对象
a.x = a //124对象的x等于空对象
{   //124
    name:&#39;a&#39;,
    x:{}
}

a.x 是什么?
因为现在的a是空对象126,所以x是undefined

</code></pre>
<pre><code class="bash">(a == 1 &amp;&amp; a==2 &amp;&amp; a==3)
</code></pre>
<h3 id="Eventloop"><a href="#Eventloop" class="headerlink" title="Eventloop"></a>Eventloop</h3><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><pre><code class="bash">var name = &#39;window&#39;;

var person1 = {
    name:&#39;person1&#39;,
    show1:function(){
        console.log(this.name)
    },
    show2:()=&gt;console.log(this.name),
    show3:function(){
        return function(){
            console.log(this.name)
        }
    },
    show4:function(){
        return ()=&gt;console.log(this.name)
    }
}

var person2 = {name:&#39;person2&#39;}

person1.show1() //person1
person1.show1.call(person2) //person2

person1.show2() // window 作用域是window,指向window
person1.show2.call(person2) //window call不能改变箭头函数指向,作用域是window



person1.show3()() //window var fn = person1.show3()  fn() 
person1.show3().call(person2) //p2  
person1.show3.call(person2)() //window 同1 

person1.show4() //p1 作用域是p1
person1.show4().call(person2) //p1 作用域是p1
person1.show4.call(person2)() //p2 作用域是p2


//////////////////////////////////////

var name = &#39;window&#39;

function Person(name){
    this.name = name;
    this.show1 = function () {
        console.log(this.name)
    }
    this.show2 = () =&gt; console.log(this.name)
    this.show3 = function () {
        return function(){
            console.log(this.name)
        }
    }
    this.show4 = function () {
        return () =&gt; console.log(this.name)
    }
}

var personA = new Person(&#39;personA&#39;)
var personB = new Person(&#39;personB&#39;)

personA.show1() //PA
personA.show1.call(personB) //pB

personA.show2() //PA 
personA.show2.call(personB) //PA

personA.show3()() //window
personA.show3().call(personB) //Pb 
personA.show3.call(personB)() //window 

personA.show4()() //PA 
personA.show4().call(personB) //pA
personA.show4.call(personB)() //Pb

///////////////////////////

function $(){
    this.count = 1;
    return this;
}
window.onload = function(){
    console.info($()); //window
}

//////////////

var point = {
    x: 0,
    y: 0,
    moveTo: function(x, y) {
        var fn1 = function(x) {
            this.x = this.x + x; 
            return this.x;
        };
        var fn2 = function(y) {
            this.y = this.y + y;
        };
        return fn1();
    }
}
console.log(point.moveTo()); //fn1() =&gt; fn1().call() NaN+0=NaN

////////

var point = {
    x: 0,
    y: 0,
    moveTo: function(x, y) {
        var that = this;
        var x = x;
        var y = y;
        var fn1 = function(x) {
            that.x = that.x + x;
            return that;
        };
        var fn2 = function(y) {
            that.y = that.y + y;
        };
        return fn1(x);
    }
}

console.log(point.moveTo(1,1)); //fn1(x) =&gt; fn1(x).call() 1+0

//////////////

var length = 10;
function fn() {
  console.log(this.length);
}

var obj = {
  length: 5,
  method: function(fn) {
    fn();
    arguments[0]();
  }
};

obj.method(fn, 1);

fn.call() //10 2




//////////////////////////////

function foo(){
    console.log(this.a)
}

var a = 3;

var obj = {
    a: 2,
    foo: foo
};

obj.foo();  //this = obj obj.a=2

/////////////////////////////////

function foo() {
    console.log( this.a )
}

var obj2 = { 
    a: 42,
    foo: foo
}

var obj1 = {
    a: 2,
    obj2: obj2
}

obj1.obj2.foo(); //this=obj2 obj2.a =42

//////////////////////////////

function foo() {
    console.log( this.a )
}

var obj1 = {
    a: 2,
    foo: foo
}

var bar = obj1.foo; 

var a = &quot;oops, global&quot;; 

bar(); //this=window window.a 

//////////////////////////

function foo() {
    console.log( this.a )
}

function doFoo( fn ){
    fn();
}

var obj = {
    a: 2,
    foo: foo
}

var a = &quot;oops, global&quot;; 

doFoo( obj.foo );  //this=window window.a

//////////////////////////////

function foo( something ) {
    console.log( this.a, something)
    return this.a + something
}

var obj = {
    a: 2
}

var bar = function() {
    return foo.apply( obj, arguments)
}

var b = bar(3);  //foo.apply(obj,3) obj.a + 3 =5
console.log(b);  //5


//////////////////////////////

function foo( something ) {
    console.log( this.a, something)
    return this.a + something
}

var obj = {
    a: 2
}

var bar = foo.bind(obj)

var b = bar(3); //同上
console.log(b); 


///////////////////////////

function foo(a){
    this.a = a
}

var bar = new foo(2); 
console.log(bar.a);  //2

///////////////////////////

function foo(a){
    console.log(this.a)
}

var obj1 = {
    a: 2,
    foo: foo
}

var obj2 = {
    a: 3,
    foo: foo
}

obj1.foo();  //2
obj2.foo();  //3

obj1.foo.call(obj2); //3 
obj2.foo.call(obj1); //2


////////////////////////////

function foo(something){
    this.a = something
}

var obj1 = {
    foo: foo
}

var obj2 = {}

obj1.foo(2);  //2
console.log(obj1.a); //2 

obj1.foo.call(obj2,3);  //3
console.log(obj2.a); //3

var bar = new obj1.foo(4) 
console.log(obj1.a); //2,因为上面obj1.foo(2)已赋值
console.log(bar.a);//4

///////////////////////////

function foo(something){
    this.a = something
}

var obj1 = {}

var bar = foo.bind(obj1);
bar(2); //obj1 = {a:2}
console.log(obj1.a); //2 

var baz = new bar(3); 
console.log(obj1.a); //2
console.log(baz.a); //3

/////////////////////////

function foo(p1,p2){
    this.val = p1 + p2;
}

var bar = foo.bind(null,&#39;p1&#39;); 

var baz = new bar(&#39;p2&#39;);

baz.val; //
}

//////////////////////////

function foo() {
    return (a) =&gt; {
        console.log(this.a)
    };
}

var obj1 = {
    a: 2
};

var obj2 = {
    a: 3
};

var bar = foo.call(obj1);//2
bar.call(obj2); //2

/////////////////////////

function foo() {
    getName = function () { console.log (1); };
    return this;
}
foo.getName = function () { console.log(2);};
foo.prototype.getName = function () { console.log(3);};
var getName = function () { console.log(4);};
function getName () { console.log(5);}

foo.getName ();                // 2
getName ();                    // 4
foo().getName ();              // 4 x 1 函数内覆盖了下面的function genName(){}
getName ();                    // 4 x 1 上面
new foo.getName ();            // 3 x 2 先执行后面的,再new
new foo().getName ();          // 3
new new foo().getName ();      // 3
</code></pre>
</script></li></ol></li></ol></div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">Roxas Deng</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2019/07/28/面试题/">http://yoursite.com/2019/07/28/面试题/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="http://yoursite.com">Roxas Deng的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/面试/">面试</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML"><span class="toc-number">1.</span> <span class="toc-text">HTML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS"><span class="toc-number">2.</span> <span class="toc-text">CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS"><span class="toc-number">3.</span> <span class="toc-text">JS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM"><span class="toc-number">4.</span> <span class="toc-text">DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP"><span class="toc-number">5.</span> <span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue"><span class="toc-number">6.</span> <span class="toc-text">Vue</span></a></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2019/07/29/移动端开发的几个常见问题/">&lt; 移动端开发的几个常见问题</a><a class="next" href="/2019/07/27/虚拟dom/">虚拟dom &gt;</a></div></section><footer><p>Copyright © 2016 - 2023 <a href="/." rel="nofollow">RoxasDengBlog</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>